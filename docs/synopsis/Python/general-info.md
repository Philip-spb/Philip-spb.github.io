---
layout: default
title: "Общая информация"
grand_parent: "Конспекты"
parent: "Python"
nav_order: 3
---

# Общая информация

## Базовые типы данных

| тип      | описание                     |
| -------- | ---------------------------- |
| int      | целые числа *123*            |
| float    | вещественные числа *123.0*   |
| str      | строки                       |
| bool     | булевы переменные            |
| NoneType | None type                    |
| complex  | комплексные числа *2.0 + 3j* |
| bytes    | байтовая строка              |

## Побитовые операции

```py
x = 10  # в двоичной кодировке 0000_1010
y = 6  # в двоичной кодировке 0000_0110

print("Побитовое ИЛИ:", f'{x | y:09_b}')  # 0000_1110
print("Побитовое И:", f'{x & y:09_b}')  # 000_0010
print("Побитовое исключающее ИЛИ:", f'{y ^ 1:09_b}')  # 0000_1100
print("Побитовый сдвиг влево:", f'{y << 1:09_b}')  # 0000_1100
print("Побитовый сдвиг вправо:", f'{x >> 1:09_b}')  # 0000_0101
print("Инверсия битов:", f'{~x:09_b}')  # -000_1011
```

## Работа со списками

Копирование списков

```py
list1 = [1, 2 ,3]
list2 = list1[:]
list3 = list1.copy()
list4 = list1  # в этом случае мы не копируем список, а только копируем ссылку на список
```

В случае если список содержит вложенные списки, то для копирования необходимо использовать специальную библиотеку copy

```py
import copy
list1 = [1, [2, 3], 4]
list2 = copy.deepcopy(list1)
```

В противном случае при редактировании элемента с индексом 1 мы изменим его во всех списках

## Работа с множествами

Удаление элемента из множества

```py
my_set = {1, 2, 3, 4}
my_set.delete(4)
my_set.delete(4)  # Вызовет ошибку
my_set.discard(4)  # В этом случае ошибка не вызовется, но и удалено ничего не будет
```

Операции над множествами

```py
set1 = {1, 2, 3}
set2 = {2, 3, 4, 5}

new_set1 = set1 | set2  # объединение множеств
new_set2 = set1 & set2  # пересечение множеств
new_set3 = set1 - set2  # разность множеств
new_set4 = set2 - set1  # new_set3 не равно new_set4
new_set5 = set1 ^ set2  # симметрическая разность множеств (new_set3 | new_set4)

set3 = set1.copy()  # копирование множества
```

Для создания неизменяемого множества можно использовать frozenset

```py
my_set = {1, 2, 3}
frozen_set = frozenset(my_set)
```
